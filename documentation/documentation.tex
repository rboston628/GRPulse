\documentclass[notitlepage]{report}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{calc}

\usepackage{chapterbib}

\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\topmargin}{-.5in}
\setlength{\headheight}{0in}
\setlength{\textheight}{9in}

\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{xcolor}
%\usepackage{wrapfig}

%\setcitestyle{square, numbers}

%% MACROS FOR CHANGING ISSUES IN CODE
\newcommand{\mypaper}{\href{}{Boston (2022)}}
\def\myemail{rboston628@gmail.com}
\def\updatedate{(07/15/2021) }
\def\version{1.0}

%make typewritten zeros correct
\usepackage[T1]{fontenc}
\usepackage[scaled]{inconsolata}%use either inconsolata or beramono

%basic commands
\newcommand{\into}{\rightarrow}
\newcommand{\abs}[1]{\left\vert #1 \right\vert}

%derivaties
\newcommand{\del}[2]{\frac{\partial#1}{\partial #2}}
\newcommand{\dif}[2]{\frac{d#1}{d#2}}

%vector stuff
\newcommand{\m}[1]{\mathbf{#1}}
\newcommand{\mxi}{\boldsymbol{\xi}}
%\newcommand{\bs}[1]{\boldsymbol{#1}}
\newcommand{\dotprod}{\boldsymbol{\cdot}} % the typical scalar product

\newcommand{\Mstar}{M_\star}
\newcommand{\Rstar}{R_\star}
\newcommand{\Lstar}{L_\star}
\newcommand{\Msolar}{M_\odot}
\newcommand{\Rsolar}{R_\odot}
\newcommand{\Lsolar}{L_\odot}
\newcommand{\ad}{\text{ad}}
\newcommand{\rad}{\text{rad}}


\setcounter{section}{0}
\setcounter{subsection}{0}




%1.a.b
\renewcommand{\labelenumi}{\arabic{enumi}.}
\renewcommand{\labelenumii}{(\alph{enumii})}
\renewcommand{\labelenumiii}{(\alph{enumiii})}

\newcommand{\tclass}[1]{\text{\tt#1}}
\newcommand{\tcode}[1]{\text{\tt#1}}
\newcommand{\tfile}[1]{\text{\tt#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\title{GRPulse Documentation v\version}
\date{\today}
%\received{}

\author{S.~Reece Boston\footnote{\href{mailto:\myemail}{\myemail}}}
\maketitle

\section*{Diagrammatic Table of Contents}
Click on a box in the below code diagram to jump to the relevant chapter.  Green boxes are not yet included.
\begin{center}
\input{structurediagram}
\end{center}


\tableofcontents


\chapter{Introduction}
This document contains development notes and user notes for the \tcode{GRPulse} program developed as part of my thesis work.  This document explains the equations and algorithms used, why certain choices are made, and how to use and further develop the program.

\section{How to Cite This Program}
If you use this program in scientific research, please cite it by the paper introducing it: \mypaper

In bibtex
\begin{verbatim}
@PHDTHESIS{Boston2022,
	title = {Newtonian and Relativistic White Dwarf Asteroseismology},
	author = {Boston, S.~Reece},
	school = {University of North Carolina},
	year = {2022}
}
\end{verbatim}



\section{Version \version}
This documentation was created for release with version \version, which was released with the above paper.  Later updates will include functionality for realistic simple WD models, and for asteroseismology in full general relativity.

\section{Structure of Program}

The program follows OOP design.  Most control of the program is contained within methods attached to classes.  The classes act to encapsulate data and methods.

One of the benefits of OOP design is polymorphism; the ability to use different classes interchangeably.  This is facilitated by the use of abstract classes. There are three main abstract classes in the code:
\begin{itemize}
\item \tclass{Star}: Represents an equilibrium model of a star used as background in the wave equations.
Described in \ref{class:Star}.
\item \tclass{Mode<N>}: Represents a single $klm$-mode, described by an \tcode{N}-dimensional eigenfunction (e.g. for a Cowling mode \tcode{N}=2).
Described in \ref{class:Mode}.
\item \tclass{ModeDriver}: Represents a particular form of a stellar wave equation (e.g. Cowling modes, Dziembowski equations, or non-adiabatic waves). 
Described in \ref{class:ModeDriver}.
\end{itemize}
Classes \tclass{Star} and \tclass{ModeDriver} are abstract, meaning they only provide a template that other classes have to follow.
It is up to the children of \tclass{Star} and \tclass{ModeDriver} to actually implement those methods.

The structure of the code, the polymorphism pattern, and the relationship between the classes, is illustrated in Figure \ref{fig:struct}.

In this document, we separate two facets of the classes, as they relate to the OOP structure:
\begin{description}
	\item[Interface] External-facing elements (data or functions) that specify how outside code can interact with the object.
	\item[Implementation] The internal logic that calculates all relevant values inside of the object, and cannot be seen by external code.
\end{description}
As an example, all \tclass{Star}s have an method \tcode{rho()} in their interface, which must return the density $\rho$; however, the implementation can vary on how $\rho$ is found, whether by storing $\rho$ in an array, or calculating it from other quantities.  
 
This is illustrated in Figure \ref{fig:interface}.

\begin{figure}[h]
\hfill
\begin{tikzpicture}
  \draw[thick] (0,0) rectangle (4,5);
  \node[thick, anchor=south west] at (0,0) {\tclass{Star}};
  \draw[thick] (4,4) rectangle (6, 4.5);
  \draw[thick] (4,2) rectangle (5, 2.5);
  \node[thick, anchor=south east] at (6,4) {\tcode{rho()}};
  \node[thick, anchor=south east] at (5,2) {\tcode{P()}};

  \draw[thick,color=red] (0.5,0.5) rectangle (3.5,4.5);
  \node[thick, color=red, anchor=south west] at (0.5,0.5) {\tclass{Polytrope}};
  \draw[color=red] (2, 3.2) ellipse [x radius=1.25,y radius=0.5];
  \draw[color=red] (2, 2) ellipse [x radius=1.25, y radius=0.5];
  \node[color=red] at (2,3.2) {$\rho = \rho_c\theta^n$};
  \node[color=red] at (2,2) {$P = P_c \theta^{n+1}$};
  \draw[thick, color=red, ->] (3,3.2) -| (3.75, 4.25) -- (4, 4.25);
  \draw[thick, color=red, ->] (3,2) -| (3.75, 2.25) -- (4, 2.25);
\end{tikzpicture}
\hfill
\begin{tikzpicture}
  \draw[thick] (0,0) rectangle (4,5);
  \node[thick, anchor=south west] at (0,0) {\tclass{Star}};
  \draw[thick] (4,4) rectangle (6, 4.5);
  \draw[thick] (4,2) rectangle (5, 2.5);
  \node[thick, anchor=south east] at (6,4) {\tcode{rho()}};
  \node[thick, anchor=south east] at (5,2) {\tcode{P()}};

  \draw[thick,color=green] (0.5,0.5) rectangle (3.5,4.5);
  \node[thick, color=green, anchor=south west] at (1,1) {\tclass{MESA}};
  \draw[color=green] (2, 3.2) ellipse [x radius=1.25,y radius=0.5];
  \draw[color=green] (2, 2) ellipse [x radius=1.25, y radius=0.5];
  \node[color=green] at (2,3.2) {$\rho = \frac{M}{4\pi R^3} \tilde{\rho}$};
  \node[color=green] at (2,2) {$P = \frac{GM^2}{4\pi R^4} \tilde{P}$};
  \draw[thick, color=green, ->] (3,3.2) -| (3.75, 4.25) -- (4, 4.25);
  \draw[thick, color=green, ->] (3,2) -| (3.75, 2.25) -- (4, 2.25);
\end{tikzpicture}
\hfill
\caption{An illustration of a class (the boxes labeled \tclass{Star}).  The interface (the ``pipes'' \tcode{rho()}, \tcode{P()}) can connect to external code needing a star's density and pressure.  The internal logic of the implementation (the circles) is illustrated for two \tclass{Star} daughters: the \tclass{Polytrope} class (red) and the \tclass{MESA} class (green). External code cannot access the internal implementation, and does not care what kind of star is returning $\rho,P$.\label{fig:interface}}
\end{figure}

\section{How to Use This Program}
Two uses of this code are intended:
\begin{enumerate}
\item using the \tcode{GRPulse} program to calculate eigenfrequencies of the included stellar models.  The I/O is handled by text files and explained in Chapter \ref{chapter:grpulse}.  To run the \tcode{GRPulse} program, you must first compile it by running the included make file.
\item as a library of C++ classes for asteroseismology.  Several programs in the \tfile{testing} suite will show the individual class files being used in this way.  This document hopes to explain ways the library can be adapted or extended to other purposes.
\end{enumerate}

\section{Diagram of Program Structure}
\begin{figure}[h]
\begin{center}
\input{structurediagram}
\caption{Structure of program, showing hierarchies.  Red boxes are abstract classes, which provide rules for child classes to follow.  Blue lines show friendship.  Green planned but unimplemented.  Any figure lower in the hierarchy (a child) can be used in place of a parent or grandparent class.  Therefore, a \tclass{ChandrasekharWD} can be used anywhere the program calls for a \tclass{Star}.\label{fig:struct}}
\end{center}
\end{figure}


\input{grpulse}

%% abstract classes
\part{Base Classes}
\input{./STARS/Star}

\input{./MODES/ModeDriver}

\input{./MODES/Mode}

%% stars
\part{Stellar Models\label{part:stars}}

\input{./STARS/Polytrope}

\input{./STARS/ChandrasekharWD}

\input{./STARS/MESA}

\input{./STARS/PNStar}

\input{./STARS/PNPolytrope}

\input{./STARS/GRStar}

\input{./STARS/GRPolytrope}

%% mode drivers
\part{Mode Drivers\label{part:drivers}}

\input{./MODES/NonradialModeDriver}

\input{./MODES/CowlingModeDriver}

\input{./MODES/PNNonradialModeDriver}

\input{./MODES/GRCowlingModeDriver}



\end{document}